Now I have gathered comprehensive information about Bolt.new best practices, modern web development trends, and effective prompting techniques. Let me create fully optimized project instructions for Bolt.new that incorporate all the best practices and advice.

# Optimized Project Instructions for Bolt.new: Complete Web Application Development Guide

## Initial Project Setup & Architecture

### Framework Selection & Technical Foundation
**Define your technical stack upfront to guide Bolt's development approach:**

- **Frontend Framework**: React (recommended), Vue.js, or Angular based on project complexity
- **Styling**: Tailwind CSS for utility-first design and rapid development
- **State Management**: Context API for simple apps, Redux/Zustand for complex state
- **Database**: Supabase for full-stack applications with authentication
- **Deployment**: Netlify (integrated) or Vercel for seamless deployment

### Project Structure Best Practices
**Establish clear architecture from the beginning:**

project-root/
├── src/
│   ├── components/     # Reusable UI components
│   ├── pages/         # Route-based page components
│   ├── hooks/         # Custom React hooks
│   ├── utils/         # Helper functions
│   ├── styles/        # Global styles
│   └── assets/        # Images, icons, etc.
├── public/            # Static assets
└── docs/             # Project documentation

## Effective Prompting Strategies

### 1. Foundation Prompt Structure
**Start with a comprehensive initial prompt that covers all essential elements:**

Create a [type of application] using [framework] with the following specifications:

**Purpose & Goals:**
- Primary objective: [clear business goal]
- Target users: [specific user demographics]
- Key success metrics: [measurable outcomes]

**Core Features:**
- Feature 1: [detailed description with user flow]
- Feature 2: [specific functionality requirements]
- Feature 3: [integration needs]

**Technical Requirements:**
- Framework: [React/Vue/Angular]
- Styling: [Tailwind CSS/styled-components]
- Authentication: [if needed]
- Database: [Supabase/Firebase if applicable]

**Design Specifications:**
- Visual style: [modern, minimalist, professional, etc.]
- Color scheme: [primary colors with hex codes if known]
- Typography: [font preferences]
- Layout: [responsive, mobile-first approach]
- Accessibility: [WCAG 2.1 AA compliance]

**Performance Requirements:**
- Page load time: Under 3 seconds
- Core Web Vitals optimization
- Mobile-responsive design
- Progressive enhancement

### 2. Incremental Development Approach
**Build features iteratively to maintain code quality and reduce token usage:**

- **Phase 1**: Basic structure and navigation
- **Phase 2**: Core functionality (one feature at a time)
- **Phase 3**: UI refinement and styling
- **Phase 4**: Performance optimization and testing
- **Phase 5**: Authentication and security (if needed)

### 3. Specific Prompting Techniques
**Use precise, actionable prompts for better results:**

**Good Prompt Example:**
Add a contact form component with the following specifications:
- Form fields: name (required), email (required, with validation), message (required, textarea)
- Styling: Tailwind CSS with rounded corners, subtle shadows
- Validation: Real-time validation with error messages
- Submit button: Primary color with loading state
- Success message: Green toast notification
- Error handling: Display specific validation errors
```

**Avoid Vague Prompts:**
- ❌ "Add a contact form"
- ❌ "Make it look better"
- ❌ "Fix the styling"

## Modern Web Development Best Practices

### 1. Performance Optimization
**Implement performance-first development:**

- **Core Web Vitals**: Optimize LCP, FID, and CLS metrics
- **Lazy Loading**: Implement for images and non-critical components
- **Code Splitting**: Use dynamic imports for route-based splitting
- **Image Optimization**: Use modern formats (WebP, AVIF) with fallbacks
- **Caching Strategy**: Implement proper cache headers and service workers

### 2. Responsive Design & Accessibility
**Ensure inclusive and mobile-first design:**[13][14]

/* Mobile-first breakpoints */
@media (min-width: 640px) { /* sm */ }
@media (min-width: 768px) { /* md */ }
@media (min-width: 1024px) { /* lg */ }
@media (min-width: 1280px) { /* xl */ }

**Accessibility checklist:**
- Semantic HTML structure
- ARIA labels and descriptions
- Keyboard navigation support
- Color contrast ratio ≥ 4.5:1
- Focus indicators
- Screen reader compatibility

### 3. Modern UI/UX Principles
**Implement 2025 design trends:**
- **Minimalist Design**: Clean layouts with purposeful white space
- **Dark Mode Support**: System preference detection and toggle
- **Micro-interactions**: Subtle animations for user feedback
- **Progressive Enhancement**: Functional base experience with enhanced features
- **Sticky Navigation**: Persistent access to key actions

## Token Optimization Strategies

### 1. Efficient Development Workflow
**Maximize token efficiency:**[10][18]

- **Use Discussion Mode**: For planning and troubleshooting (90% fewer tokens)
- **Incremental Changes**: One feature per prompt
- **Specific File Targeting**: Right-click files to focus Bolt's attention
- **Revert Feature**: Use rollback instead of requesting fixes
- **Error Prevention**: Add comprehensive error handling upfront

### 2. Prompt Enhancement Techniques
**Leverage Bolt's built-in optimization:**[8]

- Use the "Enhance Prompt" feature for better prompt structure
- Store common instructions in the Prompt Library
- Set global system prompts for consistent preferences
- Use .bolt/ignore to exclude unnecessary files

## Advanced Development Patterns

### 1. Component Architecture
**Design for reusability and maintainability:**[14][19]

// Example reusable component structure
const Button = ({ 
  variant = 'primary', 
  size = 'md', 
  loading = false, 
  children, 
  ...props 
}) => {
  // Component logic with proper TypeScript typing
};

### 2. State Management Patterns
**Choose appropriate state solutions:**[6]

- **Local State**: useState for component-specific data
- **Shared State**: Context API for theme, auth, global settings  
- **Server State**: React Query/SWR for API data management
- **Complex State**: Redux Toolkit for large applications

### 3. API Integration Best Practices
**Implement robust data handling:**[20]

// Error boundaries and loading states
const useApiCall = (endpoint) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Proper error handling and loading states
};

## Quality Assurance & Testing

### 1. Code Quality Standards
**Ensure maintainable codebase:**[21][22]

- **ESLint/Prettier**: Consistent code formatting
- **TypeScript**: Type safety for larger projects  
- **Component Testing**: Unit tests for critical functionality
- **Accessibility Testing**: Automated WAVE/axe testing
- **Performance Monitoring**: Lighthouse CI integration

### 2. Browser Compatibility
**Support diverse user environments:**[21]

- **Progressive Enhancement**: Core functionality works everywhere
- **Graceful Degradation**: Advanced features degrade smoothly
- **Cross-browser Testing**: Chrome, Firefox, Safari, Edge
- **Mobile Testing**: iOS Safari, Chrome Mobile

## Deployment & Optimization

### 1. Production Readiness
**Prepare for live deployment:**[4][20]

- **Environment Variables**: Secure API keys and configuration
- **Build Optimization**: Tree shaking and minification
- **SEO Meta Tags**: Proper Open Graph and Twitter Card tags
- **Analytics Setup**: Google Analytics or privacy-focused alternatives
- **Error Monitoring**: Sentry or similar error tracking

### 2. Performance Monitoring
**Continuous optimization:**[12]

- **Core Web Vitals**: Regular PageSpeed Insights checks
- **User Experience**: Real user monitoring (RUM)
- **Bundle Analysis**: webpack-bundle-analyzer for optimization
- **CDN Integration**: CloudFlare or similar for global performance

## Security Best Practices

### 1. Frontend Security
**Protect user data and application integrity:**

- **Content Security Policy**: Prevent XSS attacks
- **HTTPS Enforcement**: Secure data transmission
- **Input Validation**: Client and server-side validation
- **Dependency Security**: Regular npm audit and updates
- **Authentication Security**: Proper JWT handling and storage

## Example Complete Project Prompt

Create a modern task management web application with the following comprehensive specifications:

**Application Overview:**
- Purpose: Personal productivity app for organizing daily tasks
- Target Users: Professionals and students who need task organization
- Core Value: Simple, fast task management with priority levels

**Technical Architecture:**
- Frontend: React 18 with TypeScript
- Styling: Tailwind CSS with custom design system
- State: Context API for global app state
- Storage: Local storage with Supabase integration option
- Build Tool: Vite for fast development

**Core Features (Phase 1):**
1. Task Creation: Quick add with title, description, priority (high/medium/low)
2. Task Display: Clean list view with filtering by priority/status
3. Task Management: Mark complete, edit, delete functionality
4. Responsive Design: Mobile-first approach with desktop enhancements

**Design System:**
- Colors: Primary blue (#3B82F6), secondary gray (#6B7280), success green (#10B981)
- Typography: Inter font family, clear hierarchy
- Layout: Card-based design with subtle shadows
- Animations: Smooth transitions for interactions
- Dark mode: System preference with manual toggle

**Performance Requirements:**
- Initial load: <2 seconds
- Smooth animations at 60fps
- Mobile-optimized touch interactions
- Progressive web app capabilities

**Accessibility Standards:**
- WCAG 2.1 AA compliance
- Keyboard navigation support
- Screen reader compatibility
- High contrast mode support

**Project Structure:**

src/
├── components/
│   ├── ui/           # Reusable UI components
│   ├── task/         # Task-specific components
│   └── layout/       # Layout components
├── hooks/            # Custom React hooks
├── contexts/         # React contexts
├── utils/            # Helper functions
├── types/            # TypeScript definitions
└── styles/           # Global styles


**Development Approach:**
- Start with basic task CRUD functionality
- Implement responsive design with Tailwind
- Add animations and micro-interactions
- Optimize for performance and accessibility
- Create reusable component library

Please begin with the basic project structure and core task management functionality. Focus on clean code organization and responsive design from the start.

This comprehensive guide ensures you get maximum value from Bolt.new by following proven best practices for modern web development. Remember to work incrementally, be specific in your prompts, and prioritize user experience alongside technical excellence.

By default, this template supports JSX syntax with Tailwind CSS classes, React hooks, and Lucide React for icons. Do not install other packages for UI themes, icons, etc unless absolutely necessary or I request them.

Use icons from lucide-react for logos.